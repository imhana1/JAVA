1. 프레임워크와 라이브러리의 차이
- 라이브러리는 개발자가 기능을 찾아 능동적으로 사용한다
    라이브러리는 단순한 기능의 집합 => 개발자가 기능을 찾아 써야해
- 프레임워크는 개발자가 작성한 코드를 돌려준다
    개발자의 코드를 탑재해서 돌려주기 때문에 container라고도 부른다
    개발자 입장에서는 수동적
        사용법이 정해져있어 => 내가 작성하면 어케 작동하는지는 잘 몰라도 알아서 코드가 작성됨

2. 스프링을 사용하는 이유 (IoC × AOP 컨테이너)
- 스프링은 IOC 컨테이너(제어역전 컨테이너. 스프링이 IOC를 돌려줘)
  : 코드의 흐름을 개발자가 아닌 스프링이 제어
    대표적으로 개발자가 객체를 new 하지 않고 스프링이 객체를 생성(ex @Controller)
    스프링이 객체를 생성해서 가지고 있다가 개발자가 필요로 하면 스프링이 "주입"
- 스프링은 AOP 컨테이너
  : 스프링은 반복되는 작업(ex 로그인)을 분리해서 개발자가 한 번 만들어 놓으면 필요한 곳에 스프링이 주입
        ex) @Secured <- AOP마저 어노테이션으로 만들었구나

3. 스프링이 특정 어노테이션이 걸려있는 객체를 자동으로 생성 (* 모든 객체를 생성하진x)
- 특정 어노테이션 종류: @Component, @Repository, @Service, @Controller
- 주입하는 어노테이션: @Autowired (필요한곳에 이거 적으면 거기에 스프링이 주입)

4. 스프링이생성한 객체: spring bean (스프링에 있더라도 스프링이 생성한게 아니면 스프링빈이 아니야)
- -> 주입의 대상
        * 스프링빈이 아니면 스프링의 관리대상이x 스프링이 객체도 만들고 관리도 해줌
            ex) public SampleController {} <- 스프링빈x
                @Controller
                public SampleController{} <- 스프링빈o
                그냥 값을 저장하는 클래스는 스프링이 만들 수 없어 => 빈이 아니구나
- 스프링빈의 객체 이름은 첫글자를 소문자로 바꾼 것(자바 배울때도 클래서에 하나 있는 객체는 클래스 첫글자를 소문자로 바꾼다했지)
    ex) SampleController 클래스의 빈 이름은 sampleController다
    객체를 스프링이 관리할거라 개발자 입장에선 객체 이름이 필요 없어 근데 스프링 입장에선 참조변수가 있어야하고 그 이름은 첫글자를 소문자로 바꾼거
    그래서 패키지가 달라도 빈 이름은 달라야한다 (모든 클래스의 경우x 스프링빈의 경우)
        com.example.demo.product.SampleController
        com.example.demo.member.SampleController <= 이렇게 하면 안됨! 이렇게 하면 스프링이 관리할 때 충돌남
- 3번에서 말한 4가지 어노테이션이 걸린 클래스를 스프링이 찾는데, 그 찾는 범위가
  처음에 com.example.demo로 프로젝트를 생성하면 그 하위 패키지에서만 찾는다 (설정 바꾸기 가능은 해 근데 굳이?)
    com.example.demo1.product.SampleController는 @Controller를 지정해도 빈이 될 수 없음(∵검색을 안한다)

5. 생명주기(life cycle)
- 우리가 만든 스프링빈은 스프링 컨테이너가 생성, 운영, 파괴를 담당
    객체가 태어나서 살다가 죽는 것을 생명주기 -> 생명주기에 따른 함수들 을 생명주기 메소드
- 보통은 자바 -> 자바 서블릿(웹용 자바) -> 스프링으로 넘어오는데 우리는 파이썬으로 웹 프로그래밍 기초를 했다
- 스프링은 생명주기 메소드가 아니라 생명주기 어노테이션
    @PostConstruct
    @PreDestroy

6. 클래스는 크게 값을 저장하는 클래스(Value Object)와 처리하는 클래스
- 학생이 100명이면 VO는 100개 필요, 처리하는 클래스는 Singleton
- VO는 스프링빈이 될 수 없다
- 처리하는 클래스(Controller, Service, Repository)는 싱글톤으로 관리된다

7. 스프링은 거대한 한 덩어리의 프레임워크가 아니라 레고블록을 조립하는 형식
- 스프링은 커스터마이즈 가능한 여러 객체의 조림품
- 우리가 커스터마이즈 할 수 있도록 다양한 인터페이스들을 제공한다
- @RequestParam 이 사용자가 입력한 String 을 파라미터로 바꿀 때
    형식 변환하는 한개 한개가 다 클래스
        String -> int 클래스
        String -> long 클래스
    스프링이 제공하지 않는 변환을 원하면 클래스를 만들어서 스프링에 추가하면 된다

8. HTTP 상태 코드
- 200 : 성공 (ex. 서버에서 오류가 발생하지 않았다, 에러가 안났을 뿐 문제가 없는 건 아님)
- 400 : 수신 거부 (ex."aaa" 를 보냈는데 int num 으로 받는다)
- 403 : 권한 없음
- 404 : 주소를 찾을 수 없음 (not found)
- 405 : 잘못된 메소드
- 500 : 서버에서 처리 중 오류





























