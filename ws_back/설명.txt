250617

 1. 네트워크는 거대한 1개의 통신규약이 아니라 여러 프로토콜의 협업으로 동작함
    - 통신규약을 규정하는 문서 : RFC
    - 인터넷에 연결된 장치들을 구별하는 이름을 부여하는 프로토콜 : IP (Internet protocol)
    - IP 기반으로 장치들 사이에 통신하는 프로토콜
        ㄴ TCP - 송신 장치와 수신 장치가 연결을 생성한다 (ex. 전화) - connection oriented → ex) 파일전송
        ㄴ UPD - 연결 없이 송수신 한 번 하고 끝 (ex. 이메일) - connectionless → ex) 동영상

2. HTTP 는 TCP/IP 기반의 connectionless 통신 규약
    요청을 보내면 서버는 요청을 처리한 다음 그 결과 html 을 보내주는 방식 → redirect 방식

3. AJAX : HTTP 를 개선
    개선점 : 요청을 비동기로 서버로 전송 → 서버는 변경된 데이터만 응답 → 화면을 부분 갱신
    미개선점 : 클라이언트와 서버가 양방향 통신이 가능하지만, 한 번에 한 쪽만 말할 수 있다(수신) (ex. 무전기)
             connectionless

4. WebSocket
    - 클라이언트와 서버 간에 연결을 생성하고 양방향 통신을 지원한다
    - 채팅이나 메시지를 사용할 수 있다
    - 웹소켓은 브라우저 호환성, 네트워크 구성 문제 등을 고려 X → 그런 것을 고려한 라이브러리는 SockJS 라이브러리
        ㄴ 스프링 예제, 스프링 시큐리티 연동도 SockJS 기반

5. STOMP
    - 웹소켓으로 파일 업로드를 한다든지 할 수 있다 → 웹소켓은 실시간 양방향을 지원하는 나름 소중한 시스템 자원
    - 보통 웹소켓은 양방향 실시간 메시지 전송용으로 주로 사용된다

6. ResponseUtil
    - 객체를 JSON 으로 바꾸는 역할. 바뀐 JSON 문자열로 응답하겠다
    - 스프링에서 ResponseEntity<?> 사용할 때는 이런 거 안 썼었는데?
        ㄴ 스프링 컨트롤러에서 요청 데이터를 자바 객체로 변환하는 표준 : PropertyEditor
        ㄴ 스프링 컨트롤러에서 객체를 응답 데이터로 변환하는 표준 : MessageConverter
    - 스프링 컨트롤러를 사용할 경우 JSON 메시지 컨버터가 자동 설정 + 동작
        ㄴ 컨트롤러가 아닌 경우는 개발자가 변환을 책임
    - 스프링 부트 프로젝트에는 JSON 변환을 담당하는 Jackson 이 의존성에 포함되어 있다
      부트가 자동으로 Jackson 을 메시지 컨버터에 등록 → 객체를 JSON 으로 변환을 담당
    - 스프링 시큐리티의 로그인 성공 핸들러, 로그인 실패 핸들러 등 이런 클래스 들은 일반 자바 클래스 (스프링 컨트롤러가 아님)
        ㄴ 그래서 개발자가 수동으로 JSON 변환을 담당해야 한다

7. 웹소켓은 http 기반이 아닌 독자적인 프로토콜 (ws://)
    - 백엔드에서 스프링, 스프링 시큐리티를 사용하는 이유
        ㄴ 스프링을 사용하면 STOMP 메시징과 컨트롤러가 통합되어 있음
    -  스프링 시큐리티를 사용하면 인증이 통합된다 → Principal 을 사용할 수 있다
        ㄴ 웹소켓은 독자적인 세션을 가짐
            ㄴ 이 세션은 HTTP 와 호환이 안된다 → 그러면 HTTP 세션에 저장된 로그인 정보를 어떻게 가져오지? → 진짜육두문자나오는코드가나오게됨
